window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "altk", "modulename": "altk", "kind": "module", "doc": "<p>ALTK is a software library that aims to support research in <a href=\"https://gu-clasp.github.io/static/951dfcd6d280ce7416e79e206c291358/clasp.pdf\">Unnatural Language Semantics</a> -- a program in linguistics and cognitive science that tries to describe and explain the properties of natural languages by comparing them to the much larger set of mathematically possible languages.</p>\n\n<p>A current focus is on <em>efficient communication</em>: determining whether linguistic meanings are optimized for a trade-off between cognitive complexity and communicative precision.</p>\n\n<p>There are currently two core modules. The first is <code>altk.effcomm</code>, which includes methods for measuring informativity of languages / communicative success of Rational Speech Act agents, and for language population sampling and optimization w.r.t Pareto fronts. The <code>altk.effcomm.information</code> submodule includes tools for running Information Bottleneck style analyses of languages.</p>\n\n<p>The second module is <code>altk.language</code>, which contains primitives for constructing semantic spaces, expressions, and languages.</p>\n\n<p>See the <a href=\"https://github.com/CLMBRs/altk#readme\">README</a> for examples and references.</p>\n"}, {"fullname": "altk.effcomm", "modulename": "altk.effcomm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "altk.effcomm.agent", "modulename": "altk.effcomm.agent", "kind": "module", "doc": "<p>Classes for representing communicative agents, such as Senders and Receivers figuring in Lewis-Skyrms signaling games, literal and pragmatic agents in the Rational Speech Act framework, etc.</p>\n"}, {"fullname": "altk.effcomm.agent.CommunicativeAgent", "modulename": "altk.effcomm.agent", "qualname": "CommunicativeAgent", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "altk.effcomm.agent.CommunicativeAgent.__init__", "modulename": "altk.effcomm.agent", "qualname": "CommunicativeAgent.__init__", "kind": "function", "doc": "<p>An agent that uses a language to communicate, e.g. a RSA pragmatic agent or a Lewis-Skyrms signaler.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  a language to construct a agent to define the relation between meanings and expressions, which can be used to initialize the agent matrices (e.g. <code>S</code> or <code>R</code>).</li>\n<li><strong>name:</strong>  an optional string to name the communicative agent</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "altk.effcomm.agent.CommunicativeAgent.normalized_weights", "modulename": "altk.effcomm.agent", "qualname": "CommunicativeAgent.normalized_weights", "kind": "function", "doc": "<p>Return the normalized weights of a CommunicativeAgent so that each row vector represents a probability distribution.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.agent.CommunicativeAgent.initialize_weights", "modulename": "altk.effcomm.agent", "qualname": "CommunicativeAgent.initialize_weights", "kind": "function", "doc": "<p>Initialize the agent's weight matrix.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>weights:</strong>  an np.ndarray representing the weights to initialize the agent with. By default None, and the agent's weights will be initialized uniformly.</li>\n<li><strong>initial:</strong>  {'ones', 'random'} a str reprsenting the initialization method to use. If 'ones' (default), initialize the weight matrix with <code>np.ones</code>. If 'random', initalize the weight matrix from <code>np.random.uniform</code>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">initial</span><span class=\"o\">=</span><span class=\"s1\">&#39;ones&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.agent.CommunicativeAgent.referent_to_index", "modulename": "altk.effcomm.agent", "qualname": "CommunicativeAgent.referent_to_index", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">referent</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.agent.CommunicativeAgent.index_to_referent", "modulename": "altk.effcomm.agent", "qualname": "CommunicativeAgent.index_to_referent", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.agent.CommunicativeAgent.expression_to_index", "modulename": "altk.effcomm.agent", "qualname": "CommunicativeAgent.expression_to_index", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">expression</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.agent.CommunicativeAgent.index_to_expression", "modulename": "altk.effcomm.agent", "qualname": "CommunicativeAgent.index_to_expression", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.agent.CommunicativeAgent.policy_to_indices", "modulename": "altk.effcomm.agent", "qualname": "CommunicativeAgent.policy_to_indices", "kind": "function", "doc": "<p>Maps communicative policies to weights.</p>\n\n<p>Given a expression and referent, access the corresponding weight coordinate.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>policy:</strong>  a dict of the form {\"referent\": Referent, \"expression\": expression} representing an instance of communicative behavior, which we may call a communicative action policy for this agent.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">policy</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.agent.CommunicativeAgent.sample_policy", "modulename": "altk.effcomm.agent", "qualname": "CommunicativeAgent.sample_policy", "kind": "function", "doc": "<p>Sample a communicative policy by uniformly sampling from a row vector of the agent's weight matrix specified by the index.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>index:</strong>  the integer index representing a row of the weight matrix.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>the integer index of the agent's choice</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.agent.CommunicativeAgent.to_language", "modulename": "altk.effcomm.agent", "qualname": "CommunicativeAgent.to_language", "kind": "function", "doc": "<p>Get a language from the agent, representing its current (possibly learned) communicative behavior.</p>\n\n<h6 id=\"this-function-uses\">This function uses:</h6>\n\n<blockquote>\n  <ol>\n  <li>the agent's weight matrix,</li>\n  <li>the set of expression forms, and</li>\n  <li>the set of referents</li>\n  </ol>\n</blockquote>\n\n<p>from the language the agent was initialized with to generate a new language accurately reflecting the new expression meanings, e.g. how the agent interprets expressions as meaning zero or more referents.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>threshold:</strong>  a float in [0,1] representing the cutoff for determining if a meaning (referent) can be communicated by a expression. Because weights are not initialized to 0, it is a good idea to set nonzero values as the threshold.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a Language corresponding to the form-meaning mapping defined by the communicative agent's weights.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">&#39;complexity&#39;</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"s1\">&#39;accuracy&#39;</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">}</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.agent.Speaker", "modulename": "altk.effcomm.agent", "qualname": "Speaker", "kind": "class", "doc": "<p></p>\n", "bases": "CommunicativeAgent"}, {"fullname": "altk.effcomm.agent.Speaker.__init__", "modulename": "altk.effcomm.agent", "qualname": "Speaker.__init__", "kind": "function", "doc": "<p>An agent that uses a language to communicate, e.g. a RSA pragmatic agent or a Lewis-Skyrms signaler.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  a language to construct a agent to define the relation between meanings and expressions, which can be used to initialize the agent matrices (e.g. <code>S</code> or <code>R</code>).</li>\n<li><strong>name:</strong>  an optional string to name the communicative agent</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "altk.effcomm.agent.Speaker.normalized_weights", "modulename": "altk.effcomm.agent", "qualname": "Speaker.normalized_weights", "kind": "function", "doc": "<p>Get the normalized weights of a Speaker.</p>\n\n<p>Each row vector represents a conditional probability distribution over expressions, P(e | m).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.agent.Listener", "modulename": "altk.effcomm.agent", "qualname": "Listener", "kind": "class", "doc": "<p></p>\n", "bases": "CommunicativeAgent"}, {"fullname": "altk.effcomm.agent.Listener.__init__", "modulename": "altk.effcomm.agent", "qualname": "Listener.__init__", "kind": "function", "doc": "<p>An agent that uses a language to communicate, e.g. a RSA pragmatic agent or a Lewis-Skyrms signaler.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  a language to construct a agent to define the relation between meanings and expressions, which can be used to initialize the agent matrices (e.g. <code>S</code> or <code>R</code>).</li>\n<li><strong>name:</strong>  an optional string to name the communicative agent</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "altk.effcomm.agent.Listener.normalized_weights", "modulename": "altk.effcomm.agent", "qualname": "Listener.normalized_weights", "kind": "function", "doc": "<p>Normalize the weights of a Listener so that each row vector for the heard expression e represents a conditional probability distribution over referents P(m | e).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.agent.LiteralSpeaker", "modulename": "altk.effcomm.agent", "qualname": "LiteralSpeaker", "kind": "class", "doc": "<p>A literal speaker chooses utterances without any reasoning about other agents. The literal speaker's conditional probability distribution P(e|m) is uniform over all expressions that can be used to communicate a particular meaning. This is in contrast to a pragmatic speaker, whose conditional distribution is not uniform in this way, but instead biased towards choosing expressions that are less likely to be misinterpreted by some listener.</p>\n", "bases": "Speaker"}, {"fullname": "altk.effcomm.agent.LiteralSpeaker.__init__", "modulename": "altk.effcomm.agent", "qualname": "LiteralSpeaker.__init__", "kind": "function", "doc": "<p>An agent that uses a language to communicate, e.g. a RSA pragmatic agent or a Lewis-Skyrms signaler.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  a language to construct a agent to define the relation between meanings and expressions, which can be used to initialize the agent matrices (e.g. <code>S</code> or <code>R</code>).</li>\n<li><strong>name:</strong>  an optional string to name the communicative agent</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "altk.effcomm.agent.LiteralListener", "modulename": "altk.effcomm.agent", "qualname": "LiteralListener", "kind": "class", "doc": "<p>A naive literal listener interprets utterances without any reasoning about other agents. Its conditional probability distribution P(m|e) for guessing meanings is uniform over all meanings that can be denoted by the particular expression heard. This is in contrast to a pragmatic listener, whose conditional distribution is biased to guess meanings that a pragmatic speaker most likely intended.</p>\n", "bases": "Listener"}, {"fullname": "altk.effcomm.agent.LiteralListener.__init__", "modulename": "altk.effcomm.agent", "qualname": "LiteralListener.__init__", "kind": "function", "doc": "<p>An agent that uses a language to communicate, e.g. a RSA pragmatic agent or a Lewis-Skyrms signaler.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  a language to construct a agent to define the relation between meanings and expressions, which can be used to initialize the agent matrices (e.g. <code>S</code> or <code>R</code>).</li>\n<li><strong>name:</strong>  an optional string to name the communicative agent</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "altk.effcomm.agent.PragmaticSpeaker", "modulename": "altk.effcomm.agent", "qualname": "PragmaticSpeaker", "kind": "class", "doc": "<p>A pragmatic speaker chooses utterances based on how a listener would interpret them. A pragmatic speaker may be initialized with any kind of listener, e.g. literal or pragmatic -- meaning the recursive reasoning can be modeled up to arbitrary depth.</p>\n", "bases": "Speaker"}, {"fullname": "altk.effcomm.agent.PragmaticSpeaker.__init__", "modulename": "altk.effcomm.agent", "qualname": "PragmaticSpeaker.__init__", "kind": "function", "doc": "<p>Initialize the |M|-by-|E| matrix, S, corresponding to the pragmatic speaker's conditional probability distribution over expressions given meanings.</p>\n\n<h6 id=\"the-pragmatic-speaker-chooses-expressions-to-communicate-their-intended-meaning-according-to\">The pragmatic speaker chooses expressions to communicate their intended meaning according to:</h6>\n\n<blockquote>\n  <p>P(e | m) \\propto exp(temperature * Utility(e,m))</p>\n</blockquote>\n\n<p>where</p>\n\n<pre><code>Utility(e , m) := log(P_Listener(m | e))\n</code></pre>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  the language with |M| meanings and |E| expressions defining the size of S.</li>\n<li><strong>listener:</strong>  a communicative agent storing a matrix R representing the conditional distribution over expressions given meanings.</li>\n<li><strong>temperature:</strong>  a float \\in [0,1], representing how `optimally rational' the pragmatic speaker is; 1.0 is chosen when no particular assumptions about rationality are made.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>,</span><span class=\"param\">\t<span class=\"n\">listener</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">effcomm</span><span class=\"o\">.</span><span class=\"n\">agent</span><span class=\"o\">.</span><span class=\"n\">Listener</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "altk.effcomm.agent.PragmaticListener", "modulename": "altk.effcomm.agent", "qualname": "PragmaticListener", "kind": "class", "doc": "<p>A pragmatic listener interprets utterances based on their expectations about a pragmatic speaker's decisions. A pragmatic listener may be initialized with any kind of speaker, e.g. literal or pragmatic -- meaning the recursive reasoning can be modeled up to arbitrary depth.</p>\n", "bases": "Listener"}, {"fullname": "altk.effcomm.agent.PragmaticListener.__init__", "modulename": "altk.effcomm.agent", "qualname": "PragmaticListener.__init__", "kind": "function", "doc": "<p>Initialize the |E|-by-|M| matrix, R, corresponding to the pragmatic listener's conditional probability distribution over meanings given expressions.</p>\n\n<h6 id=\"the-pragmatic-listener-chooses-meanings-as-their-best-guesses-of-the-expression-they-heard-according-to\">The pragmatic listener chooses meanings as their best guesses of the expression they heard according to:</h6>\n\n<blockquote>\n  <p>P(m | e) \\propto P_PragmaticSpeaker(e | m)</p>\n</blockquote>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  the language with |M| meanings and |E| expressions defining the size of R.</li>\n<li><strong>speaker:</strong>  a communicative agent storing a matrix S representing the  conditional distribution over expressions given meanings.</li>\n<li><strong>prior:</strong>  a diagonal matrix of size |M|-by-|M| representing the communicative need probabilities for meanings.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>,</span><span class=\"param\">\t<span class=\"n\">speaker</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">effcomm</span><span class=\"o\">.</span><span class=\"n\">agent</span><span class=\"o\">.</span><span class=\"n\">Speaker</span>,</span><span class=\"param\">\t<span class=\"n\">prior</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "altk.effcomm.agent.BayesianListener", "modulename": "altk.effcomm.agent", "qualname": "BayesianListener", "kind": "class", "doc": "<p>A Bayesian reciever chooses an interpretation according to p(meaning | word), where</p>\n\n<p>$P(m | w) = \\frac{P(M | W) \\cdot P(M)} { P(W) }$</p>\n\n<p>Furthermore, we sometimes require that each word w is deterministically interpreted as meaning $\\hat{m}$ as follows:</p>\n\n<p>$\\hat{m}_{w}(u) = \\sum_m p(m|w) \\cdot m(u)$</p>\n\n<p>See altk.effcomm.information for more details.</p>\n", "bases": "Listener"}, {"fullname": "altk.effcomm.agent.BayesianListener.__init__", "modulename": "altk.effcomm.agent", "qualname": "BayesianListener.__init__", "kind": "function", "doc": "<p>An agent that uses a language to communicate, e.g. a RSA pragmatic agent or a Lewis-Skyrms signaler.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  a language to construct a agent to define the relation between meanings and expressions, which can be used to initialize the agent matrices (e.g. <code>S</code> or <code>R</code>).</li>\n<li><strong>name:</strong>  an optional string to name the communicative agent</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">speaker</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">effcomm</span><span class=\"o\">.</span><span class=\"n\">agent</span><span class=\"o\">.</span><span class=\"n\">Speaker</span>,</span><span class=\"param\">\t<span class=\"n\">prior</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "altk.effcomm.analysis", "modulename": "altk.effcomm.analysis", "kind": "module", "doc": "<p>Functions for analyzing and formatting the results of the simplicity/informativeness trade-off.</p>\n"}, {"fullname": "altk.effcomm.analysis.get_dataframe", "modulename": "altk.effcomm.analysis", "qualname": "get_dataframe", "kind": "function", "doc": "<p>Get a pandas DataFrame for a list of languages containing efficient communication data.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>languages:</strong>  the list of languages to map into a dataframe.</li>\n<li><strong>columns:</strong>  the list of keys to a language's <code>data</code> dictionary attribute, which will comprise the columns of the resulting dataframe. By default will use all items of each language's <code>data</code> dictionary.</li>\n<li><strong>subset:</strong>  the columns to subset for duplicates</li>\n<li><strong>duplicates:</strong>  {\"drop\", \"count\", \"leave\"} whether to drop, count, or do nothing with duplicates. By default is set to \"leave\" which will leave duplicates in the dataframe.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <ul>\n  <li>data: a pandas DataFrame with rows as individual languages, with the columns specifying their data.</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">languages</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">columns</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">subset</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;complexity&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;comm_cost&#39;</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">duplicates</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;leave&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.analysis.pearson_analysis", "modulename": "altk.effcomm.analysis", "qualname": "pearson_analysis", "kind": "function", "doc": "<p>Measures pearson correlation coefficient for naturalness with a property.</p>\n\n<p>Use nonparametric bootstrap for confidence intervals.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data:</strong>  a DataFrame representing the pool of measured languages</li>\n<li><strong>predictor:</strong>  a string representing the column to measure pearson r with</li>\n<li><strong>property:</strong>  a string representing a column to measure pearson r with the predictor column</li>\n<li><strong>num_bootstrap_samples:</strong>  how many samples to bootstrap from the original data</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a dict of the pearson correlation coefficient for the predictor and the property, and bootstrapped confidence intervals for this coefficient, e.g.\n  {\n      \"rho\": (a float between -1 and 1),\n      \"confidence_intervals\": (a pandas Dataframe with the columns [\n          'bootstrap_sample_percent', 'low', 'high'\n      ])\n  }</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span>,</span><span class=\"param\">\t<span class=\"n\">predictor</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"nb\">property</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">num_bootstrap_samples</span><span class=\"o\">=</span><span class=\"mi\">100</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.analysis.trade_off_means", "modulename": "altk.effcomm.analysis", "qualname": "trade_off_means", "kind": "function", "doc": "<p>Get a dataframe with the mean tradeoff data.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>name:</strong>  a str representing the subset of the population to observe mean properties for, e.g. \"natural\" or \"population\".</li>\n<li><strong>df:</strong>  a pandas DataFrame containing data of a language population to take the means of.</li>\n<li><strong>prperties:</strong>  the properties to take means of, corresponding to columns of <code>df</code>.</li>\n</ul>\n\n<p>Examples:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">natural_means</span> <span class=\"o\">=</span> <span class=\"n\">trade_off_means</span><span class=\"p\">(</span><span class=\"s2\">&quot;natural_means&quot;</span><span class=\"p\">,</span> <span class=\"n\">natural_data</span><span class=\"p\">,</span> <span class=\"n\">properties</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">population_means</span> <span class=\"o\">=</span> <span class=\"n\">trade_off_means</span><span class=\"p\">(</span><span class=\"s2\">&quot;population_means&quot;</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">properties</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">means_df</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">concat</span><span class=\"p\">([</span><span class=\"n\">natural_means</span><span class=\"p\">,</span> <span class=\"n\">dlsav_means</span><span class=\"p\">,</span> <span class=\"n\">population_means</span><span class=\"p\">])</span><span class=\"o\">.</span><span class=\"n\">set_index</span><span class=\"p\">(</span><span class=\"s2\">&quot;name&quot;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">means_df</span>\n<span class=\"go\">                    simplicity  complexity  informativity  optimality</span>\n<span class=\"go\">    name</span>\n<span class=\"go\">    natural_means       0.772222     16.4000       0.746296    0.952280</span>\n<span class=\"go\">    population_means    0.681068     22.9631       0.525118    0.832010</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">properties</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.analysis.trade_off_ttest", "modulename": "altk.effcomm.analysis", "qualname": "trade_off_ttest", "kind": "function", "doc": "<p>Get a dataframe with a single-samples t-test results for a subpopulation against the full population.</p>\n\n<p>This is useful if we want to compare the optimality of natural languages to the full population of languages in an experiment. Because the property of 'being a natural language' is categorical, we use a single-samples T test.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>sub_population:</strong>  a pandas DataFrame representing a subset of the population to take ttests against the full language population for <code>properties</code>.</li>\n<li><strong>population_means:</strong>  a dict containing properties as keys and the mean value of the full language population for that property.</li>\n<li><strong>properties:</strong>  a list of strings corresponding to columns of the <code>sub_population</code> DataFrame and keys of the <code>population_means</code> dict.</li>\n</ul>\n\n<h6 id=\"examples\">Examples:</h6>\n\n<blockquote>\n  <div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">trade_off_ttest</span><span class=\"p\">(</span><span class=\"n\">natural_data</span><span class=\"p\">,</span> <span class=\"n\">population_means</span><span class=\"p\">,</span> <span class=\"n\">properties</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">df</span>\n<span class=\"go\">                        simplicity  complexity  informativity  optimality</span>\n<span class=\"go\">    stat</span>\n<span class=\"go\">    t-statistic          4.101937   -4.101937       3.126855    4.031027</span>\n<span class=\"go\">    Two-sided p-value    0.014830    0.014830       0.035292    0.015720</span>\n</code></pre>\n  </div>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">sub_population</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">population_means</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"n\">properties</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.information", "modulename": "altk.effcomm.information", "kind": "module", "doc": "<p>Helper functions for Rate-Distortion based (including Information Bottleneck) efficient communication analyses.</p>\n"}, {"fullname": "altk.effcomm.information.information_rate", "modulename": "altk.effcomm.information", "qualname": "information_rate", "kind": "function", "doc": "<p>Compute the information rate / complexity of the encoder q(w|m) as $I[W:M]$.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">source</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">encoder</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.information.get_rd_curve", "modulename": "altk.effcomm.information", "qualname": "get_rd_curve", "kind": "function", "doc": "<p>Use the Blahut Arimoto algorithm to obtain a list of (rate, distortion) points.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">prior</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">dist_mat</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">betas</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mf\">0.00000000e+00</span><span class=\"p\">,</span> <span class=\"mf\">8.53902602e-02</span><span class=\"p\">,</span> <span class=\"mf\">1.70780520e-01</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span>\n       <span class=\"mf\">1.27829219e+02</span><span class=\"p\">,</span> <span class=\"mf\">1.27914610e+02</span><span class=\"p\">,</span> <span class=\"mf\">1.28000000e+02</span><span class=\"p\">])</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.information.expected_distortion", "modulename": "altk.effcomm.information", "qualname": "expected_distortion", "kind": "function", "doc": "<p>$D[X, \\hat{X}] = \\sum_x p(x) \\sum_{\\hat{x}} p(\\hat{x}|x) * d(x, \\hat{x})$</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">p_x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">p_xhat_x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">dist_mat</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.information.compute_rate_distortion", "modulename": "altk.effcomm.information", "qualname": "compute_rate_distortion", "kind": "function", "doc": "<p>Compute the information rate $I(X;\\hat{X})$ and total distortion $D[X, \\hat{X}]$ of a joint distribution defind by $P(X)$ and $P(\\hat{X}|X)$.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>p_x:</strong>  array of shape <code>|X|</code> the prior probability of an input symbol (i.e., the source)</li>\n<li><strong>p_xhat_x:</strong>  array of shape <code>(|X|, |X_hat|)</code> the probability of an output symbol given the input</li>\n<li><strong>dist_mat:</strong>  array of shape <code>(|X|, |X_hat|)</code> representing the distoriton matrix between the input alphabet and the reconstruction alphabet.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a tuple containing\n      rate: rate (in bits) of compressing X into X_hat\n      distortion: expected distortion between X, X_hat</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">p_x</span>, </span><span class=\"param\"><span class=\"n\">p_xhat_x</span>, </span><span class=\"param\"><span class=\"n\">dist_mat</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.information.blahut_arimoto", "modulename": "altk.effcomm.information", "qualname": "blahut_arimoto", "kind": "function", "doc": "<p>Compute the rate-distortion function of an i.i.d distribution</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>dist_mat:</strong>  array of shape <code>(|X|, |X_hat|)</code> representing the distortion matrix between the input alphabet and the reconstruction alphabet. dist_mat[i,j] = dist(x[i],x_hat[j]). In this context, X is a random variable representing the a speaker's meaning (target referent), and X_hat is a random variable representing a listener's meaning (guessed  referent).</li>\n<li><strong>p_x:</strong>  (1D array of shape <code>|X|</code>) representing the probability mass function of the source. In this context, the prior over states of nature.</li>\n<li><strong>beta:</strong>  (scalar) the slope of the rate-distoriton function at the point where evaluation is required</li>\n<li><strong>max_it:</strong>  max number of iterations</li>\n<li><strong>eps:</strong>  accuracy required by the algorithm: the algorithm stops if there is no change in distoriton value of more than 'eps' between consequtive iterations</li>\n<li><strong>ignore_converge:</strong>  whether to run the optimization until <code>max_it</code>, ignoring the stopping criterion specified by <code>eps</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a dict of the form</p>\n\n<pre><code>{ \n    'final': a tuple of (rate, distortion) values. This is the rate (in bits) of compressing X into X_hat, and distortion between X, X_hat\n\n    'trajectory': a list of the (rate, distortion) points discovered during optimization\n}\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dist_mat</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">p_x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">beta</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">max_it</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">200</span>,</span><span class=\"param\">\t<span class=\"n\">eps</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-05</span>,</span><span class=\"param\">\t<span class=\"n\">ignore_converge</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.information.get_ib_curve", "modulename": "altk.effcomm.information", "qualname": "get_ib_curve", "kind": "function", "doc": "<p>Compute the IB curve bound (I[M:W] vs. I[W:U]) for a given semantic space. We use the embo package, which does not allow one to specify the number of betas, which means some interpolation might be necessary later.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>prior:</strong>  array of shape <code>|meanings|</code></li>\n<li><strong>space:</strong>  the ModalMeaningSpace on which meanings are defined</li>\n<li><strong>decay:</strong>  parameter for meaning distribution p(u|m) generation</li>\n<li><strong>utility:</strong>  parameter for meaning distribution p(u|m) generation</li>\n<li><strong>curve_type:</strong>  {'informativity', 'comm_cost'} specifies whether to return the (classic) IB axes of informativity vs. complexity, or the more Rate-Distortion Theory aligned axes of comm_cost vs. complexity. The latter can be obtained easily from the former by subtracting each informativity value from I[M:U], which is a constant for all languages in the same domain.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>an array of shape <code>(num_points, 2)</code> representing the list of (accuracy/comm_cost, complexity) points on the information plane.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">prior</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">space</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Universe</span>,</span><span class=\"param\">\t<span class=\"n\">decay</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">utility</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">curve_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;informativity&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.information.ib_complexity", "modulename": "altk.effcomm.information", "qualname": "ib_complexity", "kind": "function", "doc": "<p>Compute the IB encoder complexity of a language $I[M:W]$.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>, </span><span class=\"param\"><span class=\"n\">prior</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.information.ib_informativity", "modulename": "altk.effcomm.information", "qualname": "ib_informativity", "kind": "function", "doc": "<p>Compute the expected informativity (accuracy) $I[W:U]$ of a lexicon.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  the Language to measure for informativity</li>\n<li><strong>prior:</strong>  communicative need distribution</li>\n<li><strong>decay:</strong>  parameter for meaning distribution p(u|m) generation</li>\n<li><strong>utility:</strong>  parameter for meaning distribution p(u|m) generation</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>the informativity of the language I[W:U] in bits.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>,</span><span class=\"param\">\t<span class=\"n\">prior</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">decay</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">utility</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.information.ib_comm_cost", "modulename": "altk.effcomm.information", "qualname": "ib_comm_cost", "kind": "function", "doc": "<p>Compute the IB communicative cost, i.e. expected KL-divergence betweeen speaker and listener meanings, for a language.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  the Language to measure for communicative cost</li>\n<li><strong>prior:</strong>  communicative need distribution</li>\n<li><strong>decay:</strong>  parameter for meaning distribution p(u|m) generation</li>\n<li><strong>utility:</strong>  parameter for meaning distribution p(u|m) generation</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>the communicative cost, $\\mathbb{E}[D_{KL}[M || \\hat{M}]] = I[M:U] - I[W:U]$ in bits.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>,</span><span class=\"param\">\t<span class=\"n\">prior</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">decay</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">utility</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.information.language_to_joint_distributions", "modulename": "altk.effcomm.information", "qualname": "language_to_joint_distributions", "kind": "function", "doc": "<p>Given a Language, get P(M,U) the joint distribution over meanings and referents, and P(W,U) the joint distribution over words and referents.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  the Language to convert to distributions</li>\n<li><strong>prior:</strong>  communicative need distribution</li>\n<li><strong>decay:</strong>  parameter for meaning distribution p(u|m) generation</li>\n<li><strong>utility:</strong>  parameter for meaning distribution p(u|m) generation</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>,</span><span class=\"param\">\t<span class=\"n\">prior</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">decay</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">utility</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.information.language_to_ib_encoder_decoder", "modulename": "altk.effcomm.information", "qualname": "language_to_ib_encoder_decoder", "kind": "function", "doc": "<p>Convert a Language, a mapping of words to meanings, to IB encoder, q(w|m) and IB decoder q(m|w).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  the lexicon from which to infer a speaker (encoder).</li>\n<li><strong>prior:</strong>  communicative need distribution</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a dict of the form\n  {\n      \"encoder\": np.ndarray of shape <code>(|meanings|, |words|)</code>,\n      \"decoder\": np.ndarray of shape <code>(|words|, |meanings|)</code>,\n  }</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>,</span><span class=\"param\">\t<span class=\"n\">prior</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.information.deterministic_decoder", "modulename": "altk.effcomm.information", "qualname": "deterministic_decoder", "kind": "function", "doc": "<p>Compute $\\hat{m}_{w}(u) = \\sum_m  p(m|w) * m(u) $</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>decoder:</strong>  array of shape <code>(|words|, |meanings|)</code></li>\n<li><strong>meaning_distributions:</strong>  array of shape <code>(|meanings|, |meanings|)</code></li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>array of shape <code>(|words|, |meanings|)</code> representing the 'optimal' deterministic decoder</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">decoder</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">meaning_distributions</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.information.generate_meaning_distributions", "modulename": "altk.effcomm.information", "qualname": "generate_meaning_distributions", "kind": "function", "doc": "<p>Generate a conditional distribution over world states given meanings, $p(u|m)$, for each meaning.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>space:</strong>  the ModalMeaningSpace on which meanings are defined</li>\n<li><strong>decay:</strong>  a float in [0,1]. controls informativity, by decaying how much probability mass is assigned to perfect recoveries. As decay approaches 0, only perfect recovery is rewarded (which overrides any partial credit structure built into the utility/cost function). As decay approaches 1, the worst guesses become most likely.</li>\n<li><strong>cost:</strong>  a cost function defining the pairwise communicative cost for confusing one Referent in the Universe with another. If you have a (scaled) communicative utility matrix, a natural choice for cost might be <code>lambda x, y: 1 - utility(x, y)</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>p_u_m: an array of shape <code>(|space.referents|, |space.referents|)</code></p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">space</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Universe</span>,</span><span class=\"param\">\t<span class=\"n\">decay</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">cost</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span><span class=\"p\">,</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span><span class=\"p\">],</span> <span class=\"nb\">float</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.informativity", "modulename": "altk.effcomm.informativity", "kind": "module", "doc": "<p>Functions for measuring informativity in efficient communication analyses of languages.</p>\n"}, {"fullname": "altk.effcomm.informativity.informativity", "modulename": "altk.effcomm.informativity", "qualname": "informativity", "kind": "function", "doc": "<p>The informativity of a language is identified with the successful communication between a speaker and a listener.</p>\n\n<p>This function is a wrapper for <code>communicative_success</code>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  the language to compute informativity of.</li>\n<li><strong>prior:</strong>  a probability distribution representing communicative need (frequency) for meanings.</li>\n<li><strong>utility:</strong>  a function representing the usefulness of listener guesses about speaker meanings, e.g. meaning similarity. To reward only exact recovery of meanings, pass the an indicator function.</li>\n<li><strong>kind:</strong>  {\"literal, pragmatic\"} Whether to measure informativity using literal or pragmatic agents, as canonically described in the Rational Speech Act framework. The default is \"literal\".</li>\n</ul>\n\n<p><em>Concepts</em>:\n    The speaker can be thought of as a conditional distribution over expressions given meanings. The listener is likewise a conditional distribution over meanings given expressions. The communicative need, or cognitive source, is a prior probability over meanings representing how frequently agents need to use certain meanings in communication. The utility function represents the similarity, or appropriateness, of the listener's guess m' about the speaker's intended meaning m.</p>\n\n<p><em>Formula</em>:\n    The informativity of a language $L$ with meaning space $M$ is defined:</p>\n\n<p>$I(L) := \\sum_{m \\in M} p(m) \\sum_{i \\in L} p(i|m) \\sum_{\\hat{m} \\in i} p(\\hat{m}|i) * u(m, \\hat{m})$</p>\n\n<p><em>Bounds</em>:\n    A perfectly informative (=1.0) language can be constructed with a exactly one expression for each meaning.</p>\n\n<pre><code>For u() = indicator(), every language has nonzero informativity because a language must contain at least one expression, and an expression must contain at least one meaning.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>,</span><span class=\"param\">\t<span class=\"n\">prior</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">utility</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span><span class=\"p\">,</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span><span class=\"p\">],</span> <span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">agent_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;literal&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.informativity.communicative_success", "modulename": "altk.effcomm.informativity", "qualname": "communicative_success", "kind": "function", "doc": "<p>Helper function to compute the literal informativity of a language.</p>\n\n<p>$I(L) = \\sum_{m, \\hat{m}} P(m, \\hat{m}) \\cdot u(m, \\hat{m})$</p>\n\n<p>$ = \\sum_{m \\in M} p(m) \\sum_{i \\in L} p(i|m) \\sum_{\\hat{m} \\in i} p(\\hat{m} |i) \\cdot u(m, m')$</p>\n\n<p>$ = \\sum diag(p)SR \\odot U $</p>\n\n<p>For more details, see <a href=\"https://github.com/CLMBRs/altk/blob/main/docs/vectorized_informativity.pdf\">docs/vectorized_informativity</a>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>speaker:</strong>  a literal or pragmatic speaker, containing a matrix S for P(e | m)</li>\n<li><strong>listener:</strong>  a literal or pragmatic listener, containing a matrix R for P(m | e)</li>\n<li><strong>prior:</strong>  p(m), distribution over meanings representing communicative need</li>\n<li><strong>utility:</strong>  a function u(m, m') representing similarity of meanings, or pair-wise usefulness of listener guesses about speaker meanings.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">speaker</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">effcomm</span><span class=\"o\">.</span><span class=\"n\">agent</span><span class=\"o\">.</span><span class=\"n\">Speaker</span>,</span><span class=\"param\">\t<span class=\"n\">listener</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">effcomm</span><span class=\"o\">.</span><span class=\"n\">agent</span><span class=\"o\">.</span><span class=\"n\">Listener</span>,</span><span class=\"param\">\t<span class=\"n\">prior</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">utility</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span><span class=\"p\">,</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span><span class=\"p\">],</span> <span class=\"nb\">float</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.optimization", "modulename": "altk.effcomm.optimization", "kind": "module", "doc": "<p>Classes and functions for generating languages that optimize the simplicity/informativeness trade-off, e.g. via an iterative evolutionary algorithm.</p>\n"}, {"fullname": "altk.effcomm.optimization.Mutation", "modulename": "altk.effcomm.optimization", "qualname": "Mutation", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "altk.effcomm.optimization.Mutation.precondition", "modulename": "altk.effcomm.optimization", "qualname": "Mutation.precondition", "kind": "function", "doc": "<p>Whether a mutation is allowed to apply to a language.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.optimization.Mutation.mutate", "modulename": "altk.effcomm.optimization", "qualname": "Mutation.mutate", "kind": "function", "doc": "<p>Mutate the language, possibly using a list of expressions.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>,</span><span class=\"param\">\t<span class=\"n\">expressions</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.optimization.EvolutionaryOptimizer", "modulename": "altk.effcomm.optimization", "qualname": "EvolutionaryOptimizer", "kind": "class", "doc": "<p>Class for approximating the Pareto frontier of languages optimizing the simplicity/informativity trade-off.</p>\n"}, {"fullname": "altk.effcomm.optimization.EvolutionaryOptimizer.__init__", "modulename": "altk.effcomm.optimization", "qualname": "EvolutionaryOptimizer.__init__", "kind": "function", "doc": "<p>Initialize the evolutionary algorithm configurations.</p>\n\n<p>The measures of complexity and informativity, the expressions, and the mutations are all specific to the particular semantic domain.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>objectives:</strong>  a dict of the two objectives to optimize for, e.g. simplicity and informativeness, of the form, e.g.\n{\n    \"complexity\": comp_measure,\n    \"comm_cost\": lambda l: 1 - inf_measure(l)\n}</li>\n<li><strong>expressions:</strong>     a list of expressions from which to apply mutations to languages.</li>\n<li><strong>mutations:</strong>  a list of Mutation objects</li>\n<li><strong>sample_size:</strong>   the size of the population at every generation.</li>\n<li><strong>max_muatations:</strong>    between 1 and this number of mutations will be applied to a subset of the population at the end of each generation.</li>\n<li><strong>generations:</strong>   how many iterations to run the evolutionary algorithm for.</li>\n<li><strong>lang_size:</strong>     between 1 and this number of expressions comprise a language.</li>\n<li><strong>proceses:</strong>      for multiprocessing.ProcessPool, e.g. 6.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">objectives</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">],</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">expressions</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">mutations</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">effcomm</span><span class=\"o\">.</span><span class=\"n\">optimization</span><span class=\"o\">.</span><span class=\"n\">Mutation</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">sample_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">max_mutations</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">generations</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">lang_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;comm_cost&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;complexity&#39;</span></span>)</span>"}, {"fullname": "altk.effcomm.optimization.EvolutionaryOptimizer.fit", "modulename": "altk.effcomm.optimization", "qualname": "EvolutionaryOptimizer.fit", "kind": "function", "doc": "<p>Computes the Pareto frontier, a set languages which cannot be both more simple and more informative.</p>\n\n<p>Uses pygmo's nondominated_front method for computing a population's best solutions to a multi-objective optimization problem.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>seed_population:</strong>  a list of languages representing the population at generation 0 of the algorithm.</li>\n<li><strong>id_start:</strong>  the number of languages generated in the experiment so far.</li>\n<li><strong>explore:</strong>  a float in [0,1] representing how much to optimize for fitness (optimality wrt pareto front of complexity and comm_cost), and how much to randomly explore.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a dict of the estimated optimization solutions, as well as points explored along the way; of the form\n  {\n      \"dominating_languages\": list of languages as estimated solutions,\n      \"explored_languages\": list of all the languages explored during the evolutionary algorithm,\n      \"id_start\": updated number of languages generated in the experiment.\n  }</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">seed_population</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">id_start</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">explore</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.optimization.EvolutionaryOptimizer.sample_mutated", "modulename": "altk.effcomm.optimization", "qualname": "EvolutionaryOptimizer.sample_mutated", "kind": "function", "doc": "<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>languages:</strong>  dominating languages of a generation</li>\n<li><strong>amount:</strong>  sample_size.</li>\n<li><strong>expressions:</strong>  the list of expressions</li>\n<li><strong>id_start:</strong>  the number of languages generatd in the experiment so far.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a dict of the new population of languages of size=sample_size, and the updated id_start, of the form\n      {\n      \"languages\": (list of updated languages)\n      \"id_start\": (updated length of languages)\n      }</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">languages</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">amount</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">expressions</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">id_start</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.optimization.EvolutionaryOptimizer.mutate", "modulename": "altk.effcomm.optimization", "qualname": "EvolutionaryOptimizer.mutate", "kind": "function", "doc": "<p>Randomly selects a mutation that is allowed to apply and applies it to a language.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language:</strong>  the Language to mutate</li>\n<li><strong>expressions:</strong>  the list of all possible expressions. Some mutations need access to this list, so it is part of the mutation api.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>the mutated Language</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">language</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>,</span><span class=\"param\">\t<span class=\"n\">expressions</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.optimization.sample_parents", "modulename": "altk.effcomm.optimization", "qualname": "sample_parents", "kind": "function", "doc": "<p>Use the explore parameter to explore possibly suboptimal areas of the language space.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>dominating_languages:</strong>  a list of the languages with current best fitness with respect to the objectives.</li>\n<li><strong>explored_languages:</strong>  a list of all languages encountered during the evolutionary algorithm.</li>\n<li><strong>id_start:</strong>  the number of languages generated in the experiment so far.</li>\n<li><strong>explore:</strong>  a float in <code>[0,1]</code> specifying how much to explore possibly suboptimal languages. If set to 0, <code>parent_languages</code> is just <code>dominating_languages</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a dict of the languages to serve as the next generation (after possible mutations) and updated id_start, of the form</p>\n\n<pre><code>{\n    \"languages\": (list of updated languages)\n    \"id_start\": (updated length of languages)\n}\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dominating_languages</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">explored_languages</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">id_start</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">explore</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.sampling", "modulename": "altk.effcomm.sampling", "kind": "module", "doc": "<p>Functions for sampling expressions into languages.</p>\n"}, {"fullname": "altk.effcomm.sampling.get_hypothetical_variants", "modulename": "altk.effcomm.sampling", "qualname": "get_hypothetical_variants", "kind": "function", "doc": "<p>For each system (parameterized by a language or else a speaker), generate <code>num</code> hypothetical variants by permuting the signals that the system assigns to states.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>languages:</strong>  a list of languages to permute, by constructing LiteralSpeakers and permuting their weights.</li>\n<li><strong>speakers:</strong>  a list of speakers of a language, whose weights can be directly permuted. Should be used instead of <code>languages</code> if possible, because it can be more finegrained (every language can be associated with multiple speakers).</li>\n<li><strong>total:</strong>  the total number of hypothetical variants to obtain</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>hypothetical_variants: a list of type either Language or np.ndarray depending on whether <code>languages</code> or <code>speakers</code> was passed, representing hypothetical variants of the systems passed. If <code>speakers</code> was passed, a list of speakers is returned.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">languages</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">speakers</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">effcomm</span><span class=\"o\">.</span><span class=\"n\">agent</span><span class=\"o\">.</span><span class=\"n\">Speaker</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">total</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.sampling.generate_languages", "modulename": "altk.effcomm.sampling", "qualname": "generate_languages", "kind": "function", "doc": "<p>Generate languages by randomly sampling vocabularies as bags of expressions.</p>\n\n<p>A predicate (binary-valued property) of expressions may be supplied, which can be used to adjust the composition of vocabularies (e.g., by the percent of expressions satisfying the predicate).</p>\n\n<p>If sample size &lt;= nCr, then take a random sample_size set of combinations. Otherwise, to prevent repeat languages, treat nCr as the sample size.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>expressions:</strong>  a list of the possible modal expressions to sample from.</li>\n<li><strong>lang_size:</strong>  the maximum (or exact) number of expressions in each language.</li>\n<li><strong>sample_size:</strong>  the number of languages to generate.</li>\n<li><strong>criterion:</strong>  the predicate, (e.g. semantic universal) by which to split the expressions into those satisfying and those not, and then sample languages with degrees of naturalness based on the percentage from those satisfying. Must apply at the expression level. By default is a trivial criterion, so that all expressions are 'quasi-natural'.</li>\n<li><strong>fixed_wordcount:</strong>  whether to vary the language size from 1 to lang_size.</li>\n<li><strong>verbose:</strong>  How detailed the progress of sampling should be, printed to stdout.</li>\n<li><strong>dummy_name:</strong>  the default name to give to each sampled language, e.g. <code>sampled_lang_42</code>. These should not collide with any actual natural language names if the efficient communication experiment does use natural language data.</li>\n<li><strong>id_start:</strong>  an integer representing the number of languages already generated in an experiment. Languages sampled will be named according to this number. For example, if id_start is 0, the first language sampled will be named <code>sampled_lang_0</code>. Note that the largest id does not necessarily track the actual size of languages saved for the experiment, but it does track how many languages have been generated.</li>\n<li><strong>exact_sample:</strong>  a boolean representing whether to sample until the exact sample size is filled. If True, the resulting pool of languages may not be unique.</li>\n<li><strong>verbose:</strong>  a boolean representing how verbose output should be during sampling.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a dict representing the generated pool of languages and the updated id_start, of the form</p>\n\n<pre><code>{\n    \"languages\": (list of updated languages)\n    \"id_start\": (updated length of languages)\n}\n</code></pre>\n</blockquote>\n\n<h6 id=\"examples\">Examples:</h6>\n\n<blockquote>\n  <div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Turn the knob on a universal property for modals</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">expressions</span> <span class=\"o\">=</span> <span class=\"n\">load_expressions</span><span class=\"p\">(</span><span class=\"n\">expressions_file</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">universal_property</span> <span class=\"o\">=</span> <span class=\"n\">iff</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">generate_languages</span><span class=\"p\">(</span>\n<span class=\"gp\">... </span>   <span class=\"n\">ModalLanguage</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>   <span class=\"n\">expressions</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>   <span class=\"n\">lang_size</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>   <span class=\"n\">sample_size</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>   <span class=\"n\">universal_property</span><span class=\"p\">,</span>\n<span class=\"go\">...)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">languages</span> <span class=\"o\">=</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">&quot;languages&quot;</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">id_start</span> <span class=\"o\">=</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">&quot;id_start&quot;</span><span class=\"p\">]</span>\n</code></pre>\n  </div>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language_class</span><span class=\"p\">:</span> <span class=\"n\">Type</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">expressions</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">lang_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">sample_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">criterion</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"o\">&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">fixed_wordcount</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">dummy_name</span><span class=\"o\">=</span><span class=\"s1\">&#39;sampled_lang_&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">id_start</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">exact_sample</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.sampling.sample_lang_size", "modulename": "altk.effcomm.sampling", "qualname": "sample_lang_size", "kind": "function", "doc": "<p>Get a sample of languages each of exactly lang_size.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language_class:</strong>  a subclass of altk.Language</li>\n<li><strong>expressions:</strong>  a list of Expressions to sample from</li>\n<li><strong>lang_size:</strong>  int representing the maximum language size to sample</li>\n<li><strong>sample_size:</strong>  int representing the number of total languages to return</li>\n<li><strong>id_start:</strong>  an int representing the number of languages already generated in an experiment.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a dict containing the randomly sampled languages and the updated id_start, of the form</p>\n\n<pre><code>{\n    \"languages\": (list of updated languages)\n    \"id_start\": (updated length of languages)\n}\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language_class</span><span class=\"p\">:</span> <span class=\"n\">Type</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">expressions</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">lang_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">sample_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">id_start</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">dummy_name</span><span class=\"o\">=</span><span class=\"s1\">&#39;sampled_lang_id&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.sampling.sample_quasi_natural", "modulename": "altk.effcomm.sampling", "qualname": "sample_quasi_natural", "kind": "function", "doc": "<p>Turn the knob on degree quasi-naturalness for a sample of languages, either by enumerating or randomly sampling unique subsets of all possible combinations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>natural_terms:</strong>  expressions satisfying some criteria of quasi-naturalness, e.g, a semantic universal.</li>\n<li><strong>unnatural_terms:</strong>  expressions not satisfying the criteria.</li>\n<li><strong>lang_size:</strong>  the exact number of expressions a language must have.</li>\n<li><strong>sample_size:</strong>  how many languages to sample.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a dict containing the randomly sampled quasi-natural languages and the updated id_start, of the form</p>\n\n<pre><code>{\n    \"languages\": (list of updated languages)\n    \"id_start\": (updated length of languages)\n}\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language_class</span><span class=\"p\">:</span> <span class=\"n\">Type</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">natural_terms</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">unnatural_terms</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">lang_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">sample_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">id_start</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">dummy_name</span><span class=\"o\">=</span><span class=\"s1\">&#39;sampled_lang_id&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.sampling.rename_id", "modulename": "altk.effcomm.sampling", "qualname": "rename_id", "kind": "function", "doc": "<p>Updates a string of form <code>sampled_lang_X</code> with a new id for X.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.sampling.enumerate_all_languages", "modulename": "altk.effcomm.sampling", "qualname": "enumerate_all_languages", "kind": "function", "doc": "<p>When the sample size requested is greater than the size of all possible languages, just enumerate all the possible languages.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>language_class:</strong>  the kind of Language to construct</li>\n<li><strong>id_start:</strong>  a number to start counting from for assigning names with numerical ids to languages.</li>\n<li><strong>natural_indices:</strong>  the indices of quasi-natural languages already seen</li>\n<li><strong>num_natural:</strong>  the number of quasi-natural languages to sample</li>\n<li><strong>natural_terms:</strong>  the list of quasi-natural terms to sample from</li>\n<li><strong>unnatural_indices:</strong>  the indices of non-quasi-natural languages already seen</li>\n<li><strong>num_unnatural:</strong>  the number of non-quasi-natural languages to sample; 0 by default</li>\n<li><strong>unnatural_terms:</strong>  the list of non-quasi-natural terms to sample from; empty by default.</li>\n<li><strong>dummy_name:</strong>  the format of the string to name each language constructed.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a dict containing a set of languages and the updated id_start,  of the form</p>\n\n<pre><code>{\n    \"languages\": (list of updated languages)\n    \"id_start\": (updated length of languages)\n}\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">language_class</span><span class=\"p\">:</span> <span class=\"n\">Type</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">id_start</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">natural_terms</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">natural_indices</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">num_natural</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">unnatural_terms</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">unnatural_indices</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">num_unnatural</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">dummy_name</span><span class=\"o\">=</span><span class=\"s1\">&#39;sampled_lang_id&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.sampling.random_combination_vocabulary", "modulename": "altk.effcomm.sampling", "qualname": "random_combination_vocabulary", "kind": "function", "doc": "<p>Get a single vocabulary for a specific language size by choosing a random combination of natural and unnatural terms.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>seen:</strong>  the list of language indices already seen</li>\n<li><strong>num_natural:</strong>  int</li>\n<li><strong>natural_terms:</strong>  list[Expression]</li>\n<li><strong>num_unnatural:</strong>  int=0</li>\n<li><strong>unnatural_terms:</strong>  list[Expression]=[]</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>languages: the extended list of input languages.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">seen</span><span class=\"p\">:</span> <span class=\"nb\">set</span>,</span><span class=\"param\">\t<span class=\"n\">num_natural</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">natural_terms</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">num_unnatural</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">unnatural_terms</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.tradeoff", "modulename": "altk.effcomm.tradeoff", "kind": "module", "doc": "<p>Functions for constructing an efficient communication analysis by measuring the simplicity/informativeness trade-off languages and formatting results as a dataframe or a plot.</p>\n"}, {"fullname": "altk.effcomm.tradeoff.pareto_optimal_languages", "modulename": "altk.effcomm.tradeoff", "qualname": "pareto_optimal_languages", "kind": "function", "doc": "<p>Use pygmo.non_dominated_front_2d to compute the Pareto languages.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">languages</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;comm_cost&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;complexity&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">unique</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.tradeoff.pareto_min_distances", "modulename": "altk.effcomm.tradeoff", "qualname": "pareto_min_distances", "kind": "function", "doc": "<p>Measure the Pareto optimality of each language by measuring its Euclidean closeness to the frontier. The frontier is a line (list of points) interpolated from the pareto points.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points:</strong>  the list of all language (x, y) pairs, where x and y are usually communicative cost and complexity.</li>\n<li><strong>pareto_points:</strong>  the list of all dominant language (x, y) pairs to constitute the Pareto frontier. The points should have been measured by pygmo's non_dominated_front_2d function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>min_distances: an array of shape <code>len(points)</code> Euclidean distances for each language to the closest point on the Pareto frontier.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">pareto_points</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.tradeoff.interpolate_data", "modulename": "altk.effcomm.tradeoff", "qualname": "interpolate_data", "kind": "function", "doc": "<p>Interpolate the points yielded by the pareto optimal languages into a continuous (though not necessarily smooth) curve.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>points:</strong>  an list of (comm_cost, complexity) pairs of size [dominating_languages], a possibly non-smooth set of solutions to the trade-off.</li>\n<li><strong>min_cost:</strong>  the minimum communicative cost value possible to interpolate from.</li>\n<li><strong>max_cost:</strong>  the maximum communicative cost value possible to interpolate from. A natural assumption is to let complexity=0.0 if max_cost=1.0, which will result in a Pareto curve that spans the entire 2d space, and consequently the plot with x and y limits both ranging [0.0, 1.0].</li>\n<li><strong>num:</strong>  the number of x-axis points (cost) to interpolate. Controls smoothness of curve.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>interpolated_points: an array of size <code>(num, num)</code></p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">points</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">min_cost</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">max_cost</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">num</span><span class=\"o\">=</span><span class=\"mi\">5000</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.tradeoff.tradeoff", "modulename": "altk.effcomm.tradeoff", "qualname": "tradeoff", "kind": "function", "doc": "<p>Builds a final efficient communication analysis by measuring a list of languages, updating their internal data, and returning the results.</p>\n\n<p>This function measures possibly many graded or categorical properties of each language, but minimally the properties of commmunicative cost and complexity. These two measures fully define the results of an efficiency analysis, in the sense they define the optimal solutions.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>languages:</strong>  A list representing the pool of all languages to be measured for an efficient communication analysis.</li>\n<li><strong>x:</strong>  the first pressure to measure, e.g. communicative cost.</li>\n<li><strong>y:</strong>  the second pressure to measure, e.g. cognitive complexity.</li>\n<li><strong>frontier:</strong>  a list of (comm_cost, complexity) points representing a Pareto frontier to measure optimality w.r.t.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a dictionary of the population and the pareto front, of the form</p>\n\n<pre><code>{\n    \"languages\": the list of languages, with their internal efficient communication data updated,\n\n    \"dominating_languages\": the list of the languages dominating the population w.r.t. comm_cost and complexity. If no `frontier` is none, this can be considered the Pareto frontier.\n}\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">languages</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">properties</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">],</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;comm_cost&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;complexity&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">frontier</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Language</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.util", "modulename": "altk.effcomm.util", "kind": "module", "doc": "<p>Various helper functions for computing complexity and informativity.</p>\n"}, {"fullname": "altk.effcomm.util.rows_zero_to_uniform", "modulename": "altk.effcomm.util", "qualname": "rows_zero_to_uniform", "kind": "function", "doc": "<p>Ensure that <code>mat</code> encodes a probability distribution, i.e. each row (indexed by a meaning) is a distribution over expressions: sums to exactly 1.0.</p>\n\n<p>This is necessary when exploring mathematically possible languages (including natural languages, like Hausa in the case of modals) which sometimes have that a row of the matrix p(word|meaning) is a vector of 0s.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mat</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.util.build_utility_matrix", "modulename": "altk.effcomm.util", "qualname": "build_utility_matrix", "kind": "function", "doc": "<p>Construct the square matrix specifying the utility function defined for pairs of meanings, used for computing communicative success.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">universe</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Universe</span>,</span><span class=\"param\">\t<span class=\"n\">utility</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Meaning</span><span class=\"p\">,</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Meaning</span><span class=\"p\">],</span> <span class=\"nb\">float</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.util.marginal", "modulename": "altk.effcomm.util", "qualname": "marginal", "kind": "function", "doc": "<p>Compute $p(x) = \\sum_x p(x,y)$</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pXY:</strong>  a numpy array of shape <code>(|X|, |Y|)</code></li>\n</ul>\n\n<p>Returns: \n    pY: (axis = 0) or pX (default, axis = 1)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pXY</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.util.conditional", "modulename": "altk.effcomm.util", "qualname": "conditional", "kind": "function", "doc": "<p>Compute $p(y|x) = \\frac{p(x,y)}{p(x)}$</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pXY:</strong>  a numpy array of shape <code>(|X|, |Y|)</code></li>\n</ul>\n\n<p>Returns: <br />\n    pY_X: a numpy array of shape <code>(|X|, |Y|)</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pXY</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.util.joint", "modulename": "altk.effcomm.util", "qualname": "joint", "kind": "function", "doc": "<p>Compute $p(x,y) = p(y|x) \\cdot p(x) $</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pY_X:</strong>  a numpy array of shape <code>(|X|, |Y|)</code></li>\n<li><strong>pX:</strong>  a numpy array <code>|X|</code></li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>pXY: a numpy array of the shape <code>(|X|, |Y|)</code></p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pY_X</span>, </span><span class=\"param\"><span class=\"n\">pX</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.util.marginalize", "modulename": "altk.effcomm.util", "qualname": "marginalize", "kind": "function", "doc": "<p>Compute $p(y) = \\sum_x p(y|x) \\cdot p(x)$</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pY_X:</strong>  a numpy array of shape <code>(|X|, |Y|)</code></li>\n<li><strong>pX:</strong>  a numpy array of shape <code>|X|</code></li>\n</ul>\n\n<p>Returns: <br />\n    pY: a numpy array of shape <code>|Y|</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pY_X</span>, </span><span class=\"param\"><span class=\"n\">pX</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.util.bayes", "modulename": "altk.effcomm.util", "qualname": "bayes", "kind": "function", "doc": "<p>Compute $p(x|y) = \\frac{p(y|x) \\cdot p(x)}{p(y)}$</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pY_X:</strong>  a numpy array of shape <code>(|X|, |Y|)</code></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pY_X</span>, </span><span class=\"param\"><span class=\"n\">pX</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.util.xlogx", "modulename": "altk.effcomm.util", "qualname": "xlogx", "kind": "function", "doc": "<p>Compute $x \\log p(x)$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">p</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.util.H", "modulename": "altk.effcomm.util", "qualname": "H", "kind": "function", "doc": "<p>Compute the entropy of p, $H(X) = - \\sum_x x \\log p(x)$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.util.MI", "modulename": "altk.effcomm.util", "qualname": "MI", "kind": "function", "doc": "<p>Compute mutual information, $I[X:Y]$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pXY</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "altk.effcomm.util.DKL", "modulename": "altk.effcomm.util", "qualname": "DKL", "kind": "function", "doc": "<p>Compute KL divergences, $D_{KL}[p||q]$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">q</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "altk.language", "modulename": "altk.language", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "altk.language.language", "modulename": "altk.language.language", "kind": "module", "doc": "<p>Classes for modeling languages as form-meaning mappings, most important among them the Language and Expression classes.</p>\n\n<p>The base object of altk is a Language. This is intended to model a language scientifically (especially parts of its semantics) and to enable various use cases. Most notably, experiments such as analyses of efficient communication, learnability, automatic corpus generation for ML probing, etc.</p>\n"}, {"fullname": "altk.language.language.Expression", "modulename": "altk.language.language", "qualname": "Expression", "kind": "class", "doc": "<p>Minimally contains a form and a meaning.</p>\n"}, {"fullname": "altk.language.language.Expression.__init__", "modulename": "altk.language.language", "qualname": "Expression.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">form</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">meaning</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Meaning</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "altk.language.language.Expression.can_express", "modulename": "altk.language.language", "qualname": "Expression.can_express", "kind": "function", "doc": "<p>Return True if the expression can express the input single meaning point and false otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">m</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Meaning</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.language.language.Expression.yaml_rep", "modulename": "altk.language.language", "qualname": "Expression.yaml_rep", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "altk.language.language.Language", "modulename": "altk.language.language", "qualname": "Language", "kind": "class", "doc": "<p>Minimally contains Expression objects.</p>\n"}, {"fullname": "altk.language.language.Language.__init__", "modulename": "altk.language.language", "qualname": "Language.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">expressions</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "altk.language.language.Language.add_expression", "modulename": "altk.language.language", "qualname": "Language.add_expression", "kind": "function", "doc": "<p>Add an expression to the list of expressions in a language.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">e</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "altk.language.language.Language.pop", "modulename": "altk.language.language", "qualname": "Language.pop", "kind": "function", "doc": "<p>Removes an expression at the specified index of the list of expressions, and returns it.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.language.language.Language.is_natural", "modulename": "altk.language.language", "qualname": "Language.is_natural", "kind": "function", "doc": "<p>Whether a language represents a human natural language.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.language.language.Language.degree_property", "modulename": "altk.language.language", "qualname": "Language.degree_property", "kind": "function", "doc": "<p>Count what percentage of expressions in a language have a given property.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"nb\">property</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">Expression</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.language.language.Language.binary_matrix", "modulename": "altk.language.language", "qualname": "Language.binary_matrix", "kind": "function", "doc": "<p>Get a binary matrix of shape <code>(num_meanings, num_expressions)</code>\nspecifying which expressions can express which meanings.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "altk.language.semantics", "modulename": "altk.language.semantics", "kind": "module", "doc": "<p>Classes for modeling the meanings of a language.</p>\n\n<p>Meanings are modeled as things which map linguistic forms to objects of reference. The linguistic forms and objects of reference can be richly defined, but they are in some sense inaccessible at the level of a meaning. We think of meanings as informationally encapsulated instructions for building concepts.</p>\n\n<p>In efficient communication analyses, simplicity and informativeness are typically properties of semantic aspects of a language. E.g., a meaning is simple if it is easy to represent, or to compress into some code; a meaning is informative if it is easy for a listener to recover a speaker's intended literal meaning.</p>\n\n<h6 id=\"examples\">Examples:</h6>\n\n<blockquote>\n  <div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">altk.language.syntax</span> <span class=\"kn\">import</span> <span class=\"n\">Form</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">altk.language.language</span> <span class=\"kn\">import</span> <span class=\"n\">Expression</span><span class=\"p\">,</span> <span class=\"n\">Language</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">form</span> <span class=\"o\">=</span> <span class=\"n\">Form</span><span class=\"p\">(</span><span class=\"s1\">&#39;blue&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">meaning</span> <span class=\"o\">=</span> <span class=\"n\">Color_Meaning</span><span class=\"p\">()</span> <span class=\"c1\"># some default meaning</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">expression</span> <span class=\"o\">=</span> <span class=\"n\">Expression</span><span class=\"p\">(</span><span class=\"n\">form</span><span class=\"p\">,</span> <span class=\"n\">meaning</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">lang</span> <span class=\"o\">=</span> <span class=\"n\">Language</span><span class=\"p\">([</span><span class=\"n\">expression</span><span class=\"p\">])</span>\n</code></pre>\n  </div>\n</blockquote>\n"}, {"fullname": "altk.language.semantics.Referent", "modulename": "altk.language.semantics", "qualname": "Referent", "kind": "class", "doc": "<p>A referent is an object of communication.</p>\n"}, {"fullname": "altk.language.semantics.Referent.__init__", "modulename": "altk.language.semantics", "qualname": "Referent.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">weight</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "altk.language.semantics.Universe", "modulename": "altk.language.semantics", "qualname": "Universe", "kind": "class", "doc": "<p>The universe is the set of possible referent objects for a meaning.</p>\n"}, {"fullname": "altk.language.semantics.Universe.__init__", "modulename": "altk.language.semantics", "qualname": "Universe.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">referents</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "altk.language.semantics.Meaning", "modulename": "altk.language.semantics", "qualname": "Meaning", "kind": "class", "doc": "<p>A meaning picks out objects of the universe.</p>\n\n<p>There are several easy ways of modeling this.</p>\n\n<p>On one familiar model from (e.g. predicate logic and formal semantics) a semantic value can be set, called a property: the set of objects of the universe satisfying that property. A meaning can be associated with the relevant subset of the universe, or its characteristic function.</p>\n\n<p>On some efficient communication analysis models, we use the concept of meaning to be a more general mapping of forms to objects of reference.</p>\n\n<p>A meaning is always a subset of the universe, because an expression may itself be underspecified: that is, the expression can be used to express different meanings. Sometimes these different literal meanings are not equally likely, in which it can be helpful to define a meaning explicitly as a distribution.</p>\n"}, {"fullname": "altk.language.semantics.Meaning.__init__", "modulename": "altk.language.semantics", "qualname": "Meaning.__init__", "kind": "function", "doc": "<p>A meaning is the set of things it refers to.</p>\n\n<p>The objects of reference are a subset of the universe of discourse. Sometimes it is natural to construe the meaning as as a probability distribution over the universe, instead of just a binary predicate.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>dist:</strong>  a dict with referents as keys, and probabilities as values. The keys must be exactly the referents in <code>universe</code>.</li>\n<li><strong>universe:</strong>  a Universe object that defines the probability space for a meaning.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">referents</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Referent</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">universe</span><span class=\"p\">:</span> <span class=\"n\">altk</span><span class=\"o\">.</span><span class=\"n\">language</span><span class=\"o\">.</span><span class=\"n\">semantics</span><span class=\"o\">.</span><span class=\"n\">Universe</span></span>)</span>"}, {"fullname": "altk.language.semantics.Meaning.construct_distribution", "modulename": "altk.language.semantics", "qualname": "Meaning.construct_distribution", "kind": "function", "doc": "<p>Construct the probability distribution associated with the meaning.</p>\n\n<p>By default, all elements in extension are assigned equal probability. If <code>weighted</code> set to true, elements are assigned probability according proportional to their weight attribute.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>weighted:</strong>  a bool representing what weight to assign all elements in the extension of the meaning a probability.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a dict of the form</p>\n\n<pre><code>{\"referent_name\": p(referent) }\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">weighted</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "altk.language.semantics.Meaning.referents_uniform", "modulename": "altk.language.semantics", "qualname": "Meaning.referents_uniform", "kind": "function", "doc": "<p>Construct a probability distribution associated with the meaning such that every referent is equally weighted.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a dict of the form</p>\n\n<pre><code>{\"referent_name\": probability 1/len(self.referents)}\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "altk.language.semantics.Meaning.weighted_distribution", "modulename": "altk.language.semantics", "qualname": "Meaning.weighted_distribution", "kind": "function", "doc": "<p>Construct a probability distribution associated with the meaning according to the weights specified by each referent.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>a dict of the form</p>\n\n<pre><code>{\"referent_name\": p(referent) }\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "altk.language.syntax", "modulename": "altk.language.syntax", "kind": "module", "doc": "<p>Classes for modeling the forms (and structures) of a language.</p>\n\n<p>Minimally, a form is a way of distinguishing lexical items in a language, which can be thought of a packages of form and meaning. Meanings do not need to be unique, and neither do forms (consider e.g., synoymy and homophony) but you should think about how to distinguish two expressions in principle.</p>\n\n<p>In efficient communication analyses, it is possible that the simplicity/informativeness trade-off is affected by the complexity of grammatical forms.</p>\n\n<h6 id=\"typical-usage-example\">Typical usage example:</h6>\n\n<blockquote>\n  <p>from altk.language.syntax import Form\n  from altk.language.language import Expression, Language\n  form = Form('blue')\n  meaning = ColorMeaning() # some default meaning\n  expression = Expression(form, meaning)\n  lang = Language([expression])</p>\n</blockquote>\n"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();